<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrk AI Real-time Chat Interface (Non-Persistent)</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Define the font and general page layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc; /* Light background */
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .chat-layout {
            /* Main container for header and scrollable chat */
            width: 100%;
            max-width: 900px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px 0;
            /* Space reserved for the fixed input area at the bottom */
            padding-bottom: 130px; 
        }

        /* --- Fixed Input Area Styling --- */
        .fixed-input-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background-color: #f7f9fc; /* Background to cover content */
            padding-top: 10px;
            border-top: 1px solid #e5e7eb;
            box-shadow: 0 -5px 15px -3px rgba(0, 0, 0, 0.05); /* Subtle shadow above input */
        }
        .input-content-wrapper {
            /* This centers the content and provides horizontal padding */
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            padding: 0 20px 20px 20px; /* Padding for bottom and sides */
        }
        .input-bar-flex {
             /* Wrapper for the textarea/buttons to apply shadow/border once */
             background-color: #ffffff;
             border-radius: 12px;
             border: 1px solid #f3f4f6;
             box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
             display: flex;
             align-items: flex-end; /* Align elements to the bottom line */
             gap: 8px;
             padding: 8px 12px;
        }


        /* --- Chat Container Styling --- */
        #chatContainer {
            flex-grow: 1; 
            overflow-y: auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            scroll-behavior: smooth;
            max-height: 100%; /* Allows it to fill the remaining space */
        }
        
        /* Message Bubble and Markdown Styles (Same as before) */
        .message-bubble {
            max-width: 80%;
            padding: 12px 16px;
            margin-bottom: 15px;
            border-radius: 18px;
            line-height: 1.5;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
        }

        .user-message {
            margin-left: auto;
            background-color: #3b82f6;
            color: white;
            border-top-right-radius: 4px; 
            border-bottom-right-radius: 18px;
            border-top-left-radius: 18px;
            border-bottom-left-radius: 18px;
        }

        .ai-message {
            margin-right: auto;
            background-color: #eef2ff;
            color: #1f2937;
            border: 1px solid #d1d5db;
            border-top-left-radius: 4px; 
            border-bottom-left-radius: 18px;
            border-top-right-radius: 18px;
            border-bottom-right-radius: 18px;
        }
        .ai-message h3 {
            font-size: 1.125rem;
            font-weight: 700;
            margin-top: 10px;
            margin-bottom: 8px;
            color: #1d4ed8;
            padding-bottom: 4px;
            border-bottom: 1px dashed #bfdbfe;
        }
        .ai-message ul {
            list-style-type: disc;
            margin-left: 20px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .ai-message p {
            margin-top: 8px;
            margin-bottom: 8px;
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* COMPACT Image Upload Styling */
        .compact-file-label {
            /* Styling for the new image button */
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px; 
            height: 40px;
            min-width: 40px;
            border-radius: 10px;
            cursor: pointer;
            background-color: #e5e7eb; /* Gray-200 */
            color: #3b82f6; /* Blue-600 */
            transition: background-color 0.2s;
            font-size: 1.2rem;
            line-height: 1;
        }
        .compact-file-label:hover {
            background-color: #d1d5db; /* Gray-300 */
        }
        .image-preview {
            /* Styling for the small thumbnail next to the prompt */
            width: 40px;
            height: 40px;
            border-radius: 8px;
            object-fit: cover;
            border: 2px solid #3b82f6;
            transition: all 0.2s;
            margin-right: 4px;
            min-width: 40px; /* Prevent shrinking */
        }
        
        /* Textarea customization within the flex bar */
        #promptInput {
            border: none;
            padding: 4px 0; /* Vertical padding */
            background-color: transparent;
            min-height: 40px; /* Match button height for alignment */
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="chat-layout">
        <!-- Header -->
        <h1 class="text-3xl font-black text-center text-gray-900 mb-4">
            <span class="text-blue-600">M</span>ATRK <span class="text-blue-600">AI</span> Real-time Chat
        </h1>

        <!-- Chat Container (Display Area) -->
        <div id="chatContainer">
            <!-- Messages will be injected here -->
        </div>
    </div>

    <!-- Fixed Input Area Container -->
    <div id="inputWrapper" class="fixed-input-area">
        <div class="input-content-wrapper">
            <!-- Message Box for errors/info -->
            <div id="messageBox" class="message-box rounded-xl p-3 text-sm hidden mb-2 w-full"></div>

            <!-- The actual input bar (Textarea, Image Preview, Image Button, Send Button) -->
            <div class="input-bar-flex">

                <!-- Textarea (Flex-Grow) -->
                <textarea
                    id="promptInput"
                    class="flex-grow focus:outline-none focus:ring-0 resize-none text-gray-800 text-base"
                    placeholder="Type your message here..."
                    rows="1"
                    maxlength="500"
                ></textarea>
                
                <!-- Image Preview (Inline) -->
                <img id="imagePreview" src="#" alt="Image Preview" class="image-preview hidden">
                
                <!-- Image Upload Button (Label wraps hidden file input) -->
                <label for="imageUpload" class="compact-file-label" title="Upload Image">
                    <span id="imageIcon">üñºÔ∏è</span>
                </label>
                <input type="file" id="imageUpload" accept="image/png, image/jpeg, image/jpg" style="display: none;">
                
                <!-- Generate button -->
                <button
                    id="generateButton"
                    class="w-24 h-10 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-xl shadow-md transition duration-300 ease-in-out transform hover:scale-[1.02] focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center gap-1 text-sm disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Send
                    <div id="loadingSpinner" class="loading-spinner"></div>
                </button>
            </div>
        </div>
    </div>

    <script>
        // API Configuration - Key has been added
        const GEMINI_API_KEY = "AIzaSyA6mXjMO8YceJof8v3-mviE7FqbSoJ-xpw"; 
        const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
        
        // --- System Prompt (No table separators) ---
        const SYSTEM_PROMPT = `You are Matrk AI, a highly professional and advanced generative assistant, designed to process text and images and deliver well-organized, informative responses suitable for a professional setting. Format your responses using markdown: use '###' for major sections and '- ' or '* ' for standard bullet lists. Prioritize clear paragraphs and lists for presenting information. Do NOT include markdown table header separators like '| :--- |' or similar structural lines, even when generating tables.`;
        // ------------------------------------------

        // UI Elements
        const promptInput = document.getElementById('promptInput');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreview = document.getElementById('imagePreview');
        const generateButton = document.getElementById('generateButton');
        const chatContainer = document.getElementById('chatContainer');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const messageBox = document.getElementById('messageBox');

        let base64ImageData = null;
        let chatHistory = []; // Local array to hold the current session's chat history (non-persistent)

        // --- Utility Functions ---

        /**
         * Copies text to the clipboard using the older but more compatible document.execCommand('copy').
         */
        function copyResponse(text, buttonElement) {
            const textarea = document.createElement('textarea');
            // Remove markdown formatting from the text before copying
            let cleanText = text.replace(/###\s+/g, '').replace(/\*\*/g, '').replace(/^-+\s/gm, '- ');

            textarea.value = cleanText;
            document.body.appendChild(textarea);
            textarea.select();
            
            try {
                document.execCommand('copy');
                
                // Temporary success message on the button
                const originalText = buttonElement.innerHTML;
                buttonElement.innerHTML = '‚úÖ Copied!';
                setTimeout(() => {
                    buttonElement.innerHTML = originalText;
                }, 2000);

            } catch (err) {
                showMessage('Could not copy text to clipboard.', true);
                console.error('Copy command failed:', err);
            }
            document.body.removeChild(textarea);
        }

        /**
         * Simple Markdown to HTML converter for chat bubbles.
         */
        function markdownToHtml(markdown) {
            let html = markdown.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
            
            // 1. Headings (H3)
            html = html.replace(/^###\s+(.*)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(.*)$/gm, '<h3>$1</h3>');

            // 2. Bold text
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // 3. Markdown Links ([text](url) pattern)
            html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" class="text-blue-700 hover:underline">$1</a>');

            // 4. Raw URLs (e.g., https://www.example.com) -> Checks for http/s and formats as link
            const urlRegex = /(https?:\/\/[^\s<]+)/g;
            html = html.replace(urlRegex, (url) => {
                // Ensure we don't wrap a link inside another link
                if (url.includes('<a href=')) {
                    return url; 
                }
                return `<a href="${url}" target="_blank" class="text-blue-700 hover:underline">${url}</a>`;
            });
            
            // 5. Lists
            const listPattern = /(\s*[-*]\s+.*(\n\s*[-*]\s+.*)*)/g;
            html = html.replace(listPattern, (match) => {
                if (match.includes('```')) return match; 

                const listItems = match.trim().split('\n').map(item => {
                    return '<li>' + item.replace(/^[\s*-]+\s*/, '') + '</li>';
                }).join('');
                return `<ul>${listItems}</ul>`;
            });
            
            // 6. Paragraphs/Line Breaks - run last
            html = html.split('\n\n').map(p => {
                if (p.trim() === '' || p.startsWith('<h3') || p.startsWith('<ul') || p.startsWith('<hr') || p.startsWith('```') || p.startsWith('<a href=')) {
                    return p;
                }
                p = p.replace(/\n/g, '<br>');
                return `<p>${p}</p>`;
            }).join('');

            return html;
        }

        function showMessage(message, isError = false) {
            messageBox.innerHTML = message;
            messageBox.style.display = 'block';
            messageBox.style.backgroundColor = isError ? '#fee2e2' : '#dbeafe';
            messageBox.style.color = isError ? '#991b1b' : '#1e40af';
            messageBox.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        function toggleLoading(isLoading) {
            loadingSpinner.style.display = isLoading ? 'block' : 'none';
            generateButton.disabled = isLoading;
            generateButton.classList.toggle('opacity-50', isLoading);
            generateButton.classList.toggle('cursor-not-allowed', isLoading);
            generateButton.innerHTML = isLoading ? 'Wait <div id="loadingSpinner" class="loading-spinner"></div>' : 'Send';
        }

        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        /**
         * Dynamically adjust the height of the textarea based on content.
         */
        function autoResizeTextarea() {
            promptInput.style.height = 'auto';
            promptInput.style.height = promptInput.scrollHeight + 'px';
            const maxHeight = 120; // Reduced max height for compact fixed bar
            if (promptInput.scrollHeight > maxHeight) {
                promptInput.style.overflowY = 'auto';
                promptInput.style.height = maxHeight + 'px';
            } else {
                promptInput.style.overflowY = 'hidden';
            }
        }
        
        // --- Chat Rendering Functions ---
        
        function renderMessage(msg) {
            const isUser = msg.role === 'user';
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isUser ? 'user-message' : 'ai-message'}`;

            const time = new Date(msg.timestamp);
            const timeString = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // If the user message had an image, display it
            if (isUser && msg.parts.some(p => p.inlineData)) {
                const imageData = msg.parts.find(p => p.inlineData).inlineData.data;
                const img = document.createElement('img');
                img.src = `data:${msg.parts.find(p => p.inlineData).inlineData.mimeType};base64,${imageData}`;
                img.className = 'w-48 h-auto rounded-lg mb-2 shadow-md border-2 border-white';
                bubble.appendChild(img);
            }

            // Get text content
            const textContent = msg.parts.find(p => p.text)?.text || '';

            // Render text content
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = isUser ? textContent : markdownToHtml(textContent);
            bubble.appendChild(contentDiv);
            
            // --- Sources and Copy Button for AI Messages ---
            if (!isUser) {
                // Check for sources and render them
                if (msg.sources && msg.sources.length > 0) {
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.className = 'mt-3 pt-2 border-t border-blue-200 text-xs text-blue-800 space-y-1';
                    
                    const sourceTitle = document.createElement('span');
                    sourceTitle.className = 'font-semibold block mb-1 text-gray-700';
                    sourceTitle.textContent = 'Source Links (Click to Share):';
                    sourcesDiv.appendChild(sourceTitle);

                    // Limit to 3 sources for clean look
                    msg.sources.slice(0, 3).forEach((source, index) => { 
                        const a = document.createElement('a');
                        a.href = source.uri;
                        a.target = '_blank';
                        a.className = 'block hover:underline truncate text-blue-600';
                        a.textContent = `${index + 1}. ${source.title}`;
                        sourcesDiv.appendChild(a);
                    });

                    bubble.appendChild(sourcesDiv);
                }

                // Add Copy button for sharing the whole response
                const copyButton = document.createElement('button');
                copyButton.className = 'mt-2 mb-[-8px] float-right text-xs text-blue-600 hover:text-blue-800 font-semibold transition duration-150 focus:outline-none';
                copyButton.innerHTML = 'üîó Copy Response';
                // Attach the copy function
                copyButton.onclick = () => copyResponse(textContent, copyButton);
                bubble.appendChild(copyButton);
            }
            // --- END NEW ---

            // Add time label
            const timeSpan = document.createElement('span');
            timeSpan.className = `block text-right ${isUser ? 'text-blue-200' : 'text-gray-400'} text-[10px] mt-1`;
            timeSpan.textContent = timeString;
            bubble.appendChild(timeSpan);

            chatContainer.appendChild(bubble);
        }

        function showInitialWelcome() {
            const welcomeMessage = {
                role: 'model',
                parts: [{ text: "### Welcome to Matrk AI Real-time Chat\n\nI'm your professional assistant. My input box is now fixed at the bottom for better flow! Ask me anything, and I'll find relevant web links and help you share them." }],
                timestamp: new Date()
            };
            renderMessage(welcomeMessage);
        }
        
        // --- AI API Call Function with Grounding and Retries ---

        async function fetchAIResponse(currentChatHistory) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
            
            // Sanitize history by removing the local 'timestamp' and 'sources' properties
            const apiContents = currentChatHistory.map(message => ({
                role: message.role,
                parts: message.parts
            }));

            const payload = { 
                contents: apiContents, 
                // *** ENABLED GOOGLE SEARCH GROUNDING FOR WEB ACCESS (finding URLs) ***
                tools: [{ "google_search": {} }], 
                systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] }
            };

            const maxRetries = 3;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        if (response.status >= 500 && i < maxRetries - 1) {
                             // Exponential backoff delay
                            await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                            continue;
                        }
                        let errorMessage = errorData.error?.message || 'Unknown API error';
                        throw new Error(`API Error: ${response.status} - ${errorMessage}`);
                    }

                    const result = await response.json();
                    
                    const candidate = result.candidates?.[0];
                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;

                        // *** EXTRACTING SOURCES FROM GROUNDING METADATA ***
                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attribution => ({
                                    uri: attribution.web?.uri,
                                    title: attribution.web?.title,
                                }))
                                .filter(source => source.uri && source.title);
                        }
                        return { text, sources }; // Return both text and sources
                    } else {
                        if (candidate?.finishReason === 'SAFETY') {
                             return { text: "### Response Blocked\n\nI apologize, but this response was blocked due to a safety policy violation. Please rephrase your query.", sources: [] };
                        }
                        throw new Error('AI response was empty or blocked.');
                    }
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    console.error(`Retrying API call (attempt ${i + 2})...`);
                }
            }
        }


        // --- Event Listeners and Main Logic ---

        document.addEventListener('DOMContentLoaded', () => {
            showInitialWelcome();

            // Image Upload Logic
            imageUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (file.size > 5 * 1024 * 1024) {
                        showMessage('Image size exceeds 5MB limit. Please choose a smaller image.', true);
                        imagePreview.classList.add('hidden');
                        imageUpload.value = '';
                        base64ImageData = null;
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        imagePreview.src = e.target.result;
                        imagePreview.classList.remove('hidden');
                        base64ImageData = e.target.result.split(',')[1]; 
                    };
                    reader.onerror = () => {
                        showMessage('Failed to read image file.', true);
                        imagePreview.classList.add('hidden');
                        base64ImageData = null;
                    };
                    reader.readAsDataURL(file);
                } else {
                    imagePreview.classList.add('hidden');
                    base64ImageData = null;
                }
                hideMessageBox();
            });

            // Textarea auto-resize and Enter key listener
            promptInput.addEventListener('input', autoResizeTextarea);
            promptInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    generateButton.click();
                }
            });

            // Button click handler
            generateButton.addEventListener('click', async () => {
                const userPrompt = promptInput.value.trim();
                const imageSent = base64ImageData;

                if (!userPrompt && !imageSent) {
                    showMessage('Please enter a message or upload an image to send.', false);
                    return;
                }

                toggleLoading(true);
                hideMessageBox();

                // 1. Construct and Add User Message to local history and DOM
                let userParts = [{ text: userPrompt }];
                if (imageSent) {
                    const mimeType = imageUpload.files[0] ? imageUpload.files[0].type : "image/png";
                    userParts.push({
                        inlineData: {
                            mimeType: mimeType, 
                            data: imageSent
                        }
                    });
                }
                const userMessage = { 
                    role: 'user', 
                    parts: userParts, 
                    timestamp: new Date() 
                };
                
                chatHistory.push(userMessage);
                renderMessage(userMessage);
                scrollToBottom();

                // Clear input fields and image preview immediately after sending
                promptInput.value = '';
                imageUpload.value = '';
                imagePreview.classList.add('hidden');
                base64ImageData = null;
                promptInput.style.height = '40px'; // Reset textarea height

                // 2. Fetch AI Response (sending the full chat history)
                let aiResponseData = { text: "I encountered an error retrieving a professional response.", sources: [] };
                try {
                    aiResponseData = await fetchAIResponse(chatHistory);
                    
                } catch (error) {
                    console.error('AI Generation Error:', error);
                    showMessage(`AI processing failed. Details: ${error.message.substring(0, 100)}...`, true);
                    aiResponseData.text = `### Error in AI Processing\n\nI was unable to generate a response due to an internal error. (Error: ${error.message.substring(0, 100)}...)`;
                }

                // 3. Add AI Response to local history and DOM
                const aiMessage = {
                    role: 'model',
                    parts: [{ text: aiResponseData.text }],
                    timestamp: new Date(),
                    sources: aiResponseData.sources // Store sources for rendering
                };
                chatHistory.push(aiMessage);
                renderMessage(aiMessage);
                scrollToBottom();

                // Final cleanup
                toggleLoading(false);
            });
        });
    </script>
</body>
</html>
