<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrk AI Real-time Chat Interface (Non-Persistent)</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fc; /* Light background */
            min-height: 100vh;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .chat-layout {
            width: 100%;
            max-width: 900px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px 0;
        }

        /* --- Chat Container Styling --- */
        #chatContainer {
            flex-grow = 1;
            overflow-y: auto;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 16px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
            scroll-behavior: smooth;
        }

        /* Message Bubble - Base */
        .message-bubble {
            max-width: 80%;
            padding: 12px 16px;
            margin-bottom: 15px;
            border-radius: 18px;
            line-height: 1.5;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            word-wrap: break-word;
        }

        /* User Message - Right Side (Blue) */
        .user-message {
            margin-left: auto;
            background-color: #3b82f6; /* Blue-600 */
            color: white;
            border-bottom-right-radius: 4px; /* Pointed corner */
        }

        /* AI Message - Left Side (Light Gray) */
        .ai-message {
            margin-right: auto;
            background-color: #eef2ff; /* Indigo-50 */
            color: #1f2937; /* Gray-800 */
            border: 1px solid #d1d5db;
            border-bottom-left-radius: 4px; /* Pointed corner */
        }

        /* AI-specific styling within bubbles for markdown content */
        .ai-message h3 {
            font-size: 1.125rem; /* text-lg */
            font-weight: 700;
            margin-top: 10px;
            margin-bottom: 8px;
            color: #1d4ed8; /* Blue-700 */
            padding-bottom: 4px;
            border-bottom: 1px dashed #bfdbfe;
        }
        .ai-message ul {
            list-style-type: disc;
            margin-left: 20px;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .ai-message p {
            margin-top: 8px;
            margin-bottom: 8px;
        }

        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: none;
            margin-left: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom file input styling */
        .custom-file-input {
            border: 1px dashed #93c5fd;
            background-color: #f7f9fc;
            padding: 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 60px;
        }
        .custom-file-input:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .custom-file-input input[type="file"] {
            display: none;
        }
        .image-preview {
            max-width: 80px;
            max-height: 80px;
            border-radius: 6px;
            object-fit: cover;
            margin-top: 8px;
            border: 2px solid #cbd5e1;
        }
    </style>
</head>
<body>
    <div class="chat-layout">
        <!-- Header -->
        <h1 class="text-3xl font-black text-center text-gray-900 mb-4">
            <span class="text-blue-600">M</span>ATRK <span class="text-blue-600">AI</span> Real-time Chat
        </h1>

        <!-- Chat Container (Display Area) -->
        <div id="chatContainer">
            <!-- Initial welcome message added via JS -->
        </div>

        <!-- Message Box for errors/info -->
        <div id="messageBox" class="message-box rounded-xl p-3 text-sm hidden mb-4"></div>

        <!-- Inputs Wrapper -->
        <div class="space-y-3 p-4 bg-white rounded-xl shadow-lg border border-gray-100">
            
            <!-- Image Upload Area -->
            <label for="imageUpload" class="custom-file-input">
                <p class="text-blue-700 font-semibold text-sm">üñºÔ∏è Upload Image for Analysis</p>
                <input type="file" id="imageUpload" accept="image/png, image/jpeg, image/jpg">
                <img id="imagePreview" src="#" alt="Image Preview" class="image-preview hidden">
            </label>

            <!-- Input area for user prompt -->
            <div class="flex items-end space-x-2">
                <textarea
                    id="promptInput"
                    class="flex-grow p-3 border border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-400 text-gray-800 resize-none max-h-40 shadow-sm text-base"
                    placeholder="Type your message here..."
                    rows="1"
                    style="min-height: 44px;"
                ></textarea>

                <!-- Generate button -->
                <button
                    id="generateButton"
                    class="w-32 h-11 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-xl shadow-md transition duration-300 ease-in-out transform hover:scale-[1.02] focus:outline-none focus:ring-4 focus:ring-blue-300 flex items-center justify-center gap-1 text-sm"
                >
                    Send
                    <div id="loadingSpinner" class="loading-spinner"></div>
                </button>
            </div>
        </div>
    </div>

    <script>
        const GEMINI_API_KEY = "AIzaSyA6mXjMO8YceJof8v3-mviE7FqbSoJ-xpw"; // Using empty string to leverage Canvas environment's auto-key injection
        const GEMINI_MODEL = "gemini-2.5-flash-preview-09-2025";
        const SYSTEM_PROMPT = `You are Matrk AI, a highly professional and advanced generative assistant, designed to process text and images and deliver well-organized, informative responses suitable for a professional setting. Format your responses using markdown: use '###' for major sections, '- ' or '* ' for standard bullet lists, and tables for data presentation.`;

        // UI Elements
        const promptInput = document.getElementById('promptInput');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreview = document.getElementById('imagePreview');
        const generateButton = document.getElementById('generateButton');
        const chatContainer = document.getElementById('chatContainer');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const messageBox = document.getElementById('messageBox');

        let base64ImageData = null;
        let chatHistory = []; // Local array to hold the current session's chat history (with timestamp)

        // --- Utility Functions ---

        /**
         * Simple Markdown to HTML converter for chat bubbles.
         */
        function markdownToHtml(markdown) {
            let html = markdown.replace(/\r\n/g, '\n').replace(/\r/g, '\n').trim();
            
            // 1. Headings (H3)
            html = html.replace(/^###\s+(.*)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(.*)$/gm, '<h3>$1</h3>');

            // 2. Bold text
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // 3. Lists
            const listPattern = /(\s*[-*]\s+.*(\n\s*[-*]\s+.*)*)/g;
            html = html.replace(listPattern, (match) => {
                const listItems = match.trim().split('\n').map(item => {
                    return '<li>' + item.replace(/^[\s*-]+\s*/, '') + '</li>';
                }).join('');
                return `<ul>${listItems}</ul>`;
            });
            
            // 4. Paragraphs/Line Breaks - run last
            html = html.split('\n\n').map(p => {
                if (p.trim() === '' || p.startsWith('<h3') || p.startsWith('<ul') || p.startsWith('<hr')) {
                    return p;
                }
                p = p.replace(/\n/g, '<br>');
                return `<p>${p}</p>`;
            }).join('');

            return html;
        }

        function showMessage(message, isError = false) {
            messageBox.innerHTML = message;
            messageBox.style.display = 'block';
            messageBox.style.backgroundColor = isError ? '#fee2e2' : '#dbeafe';
            messageBox.style.color = isError ? '#991b1b' : '#1e40af';
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        function toggleLoading(isLoading) {
            loadingSpinner.style.display = isLoading ? 'block' : 'none';
            generateButton.disabled = isLoading;
            generateButton.classList.toggle('opacity-50', isLoading);
            generateButton.classList.toggle('cursor-not-allowed', isLoading);
        }

        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // --- Chat Rendering Functions ---
        
        function renderMessage(msg) {
            const isUser = msg.role === 'user';
            const bubble = document.createElement('div');
            bubble.className = `message-bubble ${isUser ? 'user-message' : 'ai-message'} ${isUser ? 'ml-auto' : 'mr-auto'}`;

            const time = new Date(msg.timestamp);
            const timeString = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

            // If the user message had an image, display it
            if (isUser && msg.parts.some(p => p.inlineData)) {
                const imageData = msg.parts.find(p => p.inlineData).inlineData.data;
                const img = document.createElement('img');
                img.src = `data:image/png;base64,${imageData}`;
                img.className = 'w-48 h-auto rounded-lg mb-2 shadow-md border-2 border-white';
                bubble.appendChild(img);
            }

            // Get text content
            const textContent = msg.parts.find(p => p.text)?.text || '';

            // Render text content
            const contentDiv = document.createElement('div');
            contentDiv.innerHTML = isUser ? textContent : markdownToHtml(textContent);
            bubble.appendChild(contentDiv);
            
            // Add time label
            const timeSpan = document.createElement('span');
            timeSpan.className = `block text-right ${isUser ? 'text-blue-200' : 'text-gray-400'} text-[10px] mt-1`;
            timeSpan.textContent = timeString;
            bubble.appendChild(timeSpan);

            chatContainer.appendChild(bubble);
        }

        function showInitialWelcome() {
            const welcomeMessage = {
                role: 'model',
                parts: [{ text: "### Welcome to Matrk AI Real-time Chat\n\nI'm your professional assistant. This chat is **not saved** (non-persistent). Enter your prompt or upload an image to start your analysis!" }],
                timestamp: new Date()
            };
            renderMessage(welcomeMessage);
        }
        
        // --- AI API Call Function with Retries ---

        async function fetchAIResponse(currentChatHistory) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`;
            
            // FIX: Sanitize history by removing the local 'timestamp' property
            const apiContents = currentChatHistory.map(message => ({
                role: message.role,
                parts: message.parts
            }));

            const payload = { 
                contents: apiContents, // Send the sanitized session history
                systemInstruction: { parts: [{ text: SYSTEM_PROMPT }] }
            };

            const maxRetries = 3;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        if (response.status >= 500 && i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                            continue;
                        }
                        // Check for 400 errors specifically to throw a more readable message
                        let errorMessage = errorData.error?.message || 'Unknown API error';
                        if (response.status === 400 && errorMessage.includes('Invalid JSON payload')) {
                             errorMessage = "Invalid payload (likely history formatting issue). Check console for details.";
                        }
                        throw new Error(`API Error: ${response.status} - ${errorMessage}`);
                    }

                    const result = await response.json();
                    
                    const candidate = result.candidates?.[0];
                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        return candidate.content.parts[0].text;
                    } else {
                        throw new Error('AI response was empty or blocked.');
                    }
                } catch (error) {
                    if (i === maxRetries - 1) {
                        throw error;
                    }
                    console.log(`Retrying API call (attempt ${i + 2})...`);
                }
            }
        }


        // --- Event Listeners and Main Logic ---

        document.addEventListener('DOMContentLoaded', () => {
            showInitialWelcome();

            // Image Upload Logic
            imageUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (file.size > 5 * 1024 * 1024) {
                        showMessage('Image size exceeds 5MB limit. Please choose a smaller image.', true);
                        imagePreview.classList.add('hidden');
                        imageUpload.value = '';
                        base64ImageData = null;
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        imagePreview.src = e.target.result;
                        imagePreview.classList.remove('hidden');
                        // Store the base64 part only
                        base64ImageData = e.target.result.split(',')[1]; 
                    };
                    reader.onerror = () => {
                        showMessage('Failed to read image file.', true);
                        imagePreview.classList.add('hidden');
                        base64ImageData = null;
                    };
                    reader.readAsDataURL(file);
                } else {
                    imagePreview.classList.add('hidden');
                    base64ImageData = null;
                }
                hideMessageBox();
            });

            // Drag and drop listeners (kept for convenience)
            const customFileInput = document.querySelector('.custom-file-input');
            ['dragover', 'dragleave', 'drop'].forEach(eventName => {
                customFileInput.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });
            customFileInput.addEventListener('dragover', () => customFileInput.classList.add('ring-4', 'ring-blue-200'));
            customFileInput.addEventListener('dragleave', () => customFileInput.classList.remove('ring-4', 'ring-blue-200'));
            customFileInput.addEventListener('drop', (e) => {
                customFileInput.classList.remove('ring-4', 'ring-blue-200');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    imageUpload.files = files;
                    imageUpload.dispatchEvent(new Event('change'));
                }
            });

            // Enter key press listener
            promptInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    generateButton.click();
                }
            });

            // Button click handler
            generateButton.addEventListener('click', async () => {
                const userPrompt = promptInput.value.trim();
                const imageSent = base64ImageData;

                if (!userPrompt && !imageSent) {
                    showMessage('Please enter a message or upload an image to send.', false);
                    return;
                }

                toggleLoading(true);
                hideMessageBox();

                // 1. Construct and Add User Message to local history and DOM (including timestamp for local rendering)
                let userParts = [{ text: userPrompt }];
                if (imageSent) {
                    userParts.push({
                        inlineData: {
                            mimeType: "image/png",
                            data: imageSent
                        }
                    });
                }
                const userMessage = { 
                    role: 'user', 
                    parts: userParts, 
                    timestamp: new Date() 
                };
                
                chatHistory.push(userMessage);
                renderMessage(userMessage);
                scrollToBottom();

                // Clear input fields and image preview immediately after sending
                promptInput.value = '';
                imageUpload.value = '';
                imagePreview.classList.add('hidden');
                base64ImageData = null;

                // 2. Fetch AI Response (sending the full chat history)
                let aiResponseText = "I encountered an error retrieving a professional response.";
                try {
                    aiResponseText = await fetchAIResponse(chatHistory);
                    
                } catch (error) {
                    console.error('AI Generation Error:', error);
                    // Show a cleaner error message in the UI
                    showMessage(`AI processing failed: ${error.message.substring(0, 100)}...`, true);
                    aiResponseText = `### Error in AI Processing\n\nI was unable to generate a response due to an internal error. Please try again. (Details: ${error.message})`;
                }

                // 3. Add AI Response to local history and DOM
                const aiMessage = {
                    role: 'model',
                    parts: [{ text: aiResponseText }],
                    timestamp: new Date()
                };
                chatHistory.push(aiMessage);
                renderMessage(aiMessage);
                scrollToBottom();

                // Final cleanup
                toggleLoading(false);
            });
        });
    </script>
</body>
</html>
